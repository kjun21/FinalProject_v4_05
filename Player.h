#pragma once
#include "Camera.h"
#include "Object.h"

struct VS_CB_WORLD_MATRIX2
{
	D3DXMATRIX m_d3dxmtxWorld;
};

struct VS_CB_RESULT_MATRIX2
{
	D3DXMATRIX m_d3dxmtxResult[200];
};



class CPlayer : public CGameObject
{
protected:
	// 플레이어 클래스는 카메라를 가지고 있다.
	CCamera *m_pCamera;
	bool  m_bPlayerState;
	bool m_bDamageCheck;
public:
	//플레이어를 이동하는 함수이다.
	void Move(ULONG nDirection, float fDistance, bool bVelocity = false);
	void Move(const D3DXVECTOR3& d3dxvShift, DWORD dwDirection,  bool bVelocity = false);
	void Move(float fxOffset = 0.0f, float fyOffset = 0.0f, float fzOffset = 0.0f);
	//플레이어를 회전하는 함수이다.
	void Rotate(float x, float y, float z);
	void Rotate(DWORD dwDirection, DWORD dwAttack);
	//플레이어의 위치와 회전 정보를 경과 시간에 따라 갱신하는 함수이다.
	void Update(float fTimeElapsed, DWORD dwDirection);
	//플레이어의 위치가 바뀔 때마다 호출되는 함수와 그 함수에서 사용하는 정보를 설정하는 함수이다.
	virtual void OnPlayerUpdated(float fTimeElapsed);
	void SetPlayerUpdatedContext(LPVOID pContext) { m_pPlayerUpdatedContext = pContext; }
	/*플레이어의 위치를 d3dxvPosition 위치로 설정한다.
	d3dxvPosition 벡터에서 현재 플레이어의 위치 벡터를 빼면
	현재 플레이어의 위치에서 d3dxvPosition 방향으로의 방향 벡터가 된다.
	현재 플레이어의 위치에서 이 방향 벡터 만큼 이동한다.*/
	void SetPosition(const D3DXVECTOR3& d3dxvPosition) { Move((d3dxvPosition - m_d3dxvPosition), false); }
	
	// 충돌 관련 함수
public:

	void CreateBoundingBox(float fX, float fY);
	bool CollideAABB(D3DXVECTOR3 d3dxvPosition);

	float CalculateDistance(D3DXVECTOR3 d3dxvinputPosition);
	bool CalculateCollisionRange(D3DXVECTOR3 d3dxvPlayerPosition);
	float CalculateAttackRange(float fAttackRadius, float fBeAttackedRadius);
	void CollisionCheck();
	float GetBeAttackedRadius() { return m_fBeAttackedRadius; }
	float GetAttackRadius(UINT uiAttackNum) { return m_fAttackRadius[uiAttackNum]; }
	virtual bool GetDamageCheck() { return m_bDamageCheck; }
	virtual void ISDamagedByPlayer() { cout << "플레이어, 피해를 입음!! "<< endl;  m_bDamageCheck = true; }
	virtual void ISPossibleDamageByPlayer() { cout << "플레이어, 다시 피해를 입을수 있음" << endl; m_bDamageCheck = false; }

	virtual void Die() {
		cout << "플레이어 죽음" << endl;
		m_nAnimationState = ANIMATAION_CLIP_DEATH;
		//m_bPlayerState = MONSTER_STATE_DYING;
	}
public:
	CPlayer(int nMeshes = 1);
	virtual ~CPlayer();
	//플레이어의 현재 카메라를 설정하고 반환하는 멤버 함수를 선언한다.
	void SetCamera(CCamera *pCamera) { m_pCamera = pCamera; }
	CCamera *GetCamera() { return(m_pCamera); }
	//플레이어의 상수 버퍼를 생성하고 갱신하는 멤버 함수를 선언한다.
	void CreateShaderVariables(ID3D11Device *pd3dDevice);
	void UpdateShaderVariables(ID3D11DeviceContext *pd3dDeviceContext);


protected:
	float m_fAttackRadius[2];
	float m_fBeAttackedRadius;


	//플레이어의 위치 벡터, x-축(Right), y-축(Up), z-축(Look) 벡터이다.
	D3DXVECTOR3 m_d3dxvPosition;
	D3DXVECTOR3 m_d3dxvRight;
	D3DXVECTOR3 m_d3dxvUp;
	D3DXVECTOR3 m_d3dxvLook;

	AnimationClip* m_AnimationClip;
	UINT m_nAnimationState;
	ID3D11Buffer	 *m_pd3dcbAnimation;
	D3DXMATRIX **m_ppResultMatrix;
	VS_CB_RESULT_MATRIX2 *m_cbMapData;

public:
	void SetAnimationClip(AnimationClip* animationClip) { m_AnimationClip = animationClip; }
	void UpdateAnimation(DWORD dwDirection, DWORD dwAttack);
	UINT GetAnimationState() { return m_nAnimationState; }
protected:
	//플레이어가 로컬 x-축(Right), y-축(Up), z-축(Look)으로 얼마만큼 회전했는가를 나타낸다.
	float m_fPitch;
	float m_fYaw;
	float m_fRoll;

	//플레이어의 이동 속도를 나타내는 벡터이다.
	D3DXVECTOR3 m_d3dxvVelocity;
	//플레이어에 작용하는 중력을 나타내는 벡터이다.
	D3DXVECTOR3 m_d3dxvGravity;
	//xz-평면에서 (한 프레임 동안) 플레이어의 이동 속력의 최대값을 나타낸다.
	float m_fMaxVelocityXZ;
	//y-축 방향으로 (한 프레임 동안) 플레이어의 이동 속력의 최대값을 나타낸다.
	float m_fMaxVelocityY;
	//플레이어에 작용하는 마찰력을 나타낸다.
	float m_fFriction;

	//플레이어의 위치가 바뀔 때마다 호출되는 OnPlayerUpdated() 함수에서 사용하는 데이터이다.
	LPVOID m_pPlayerUpdatedContext;
	//카메라의 위치가 바뀔 때마다 호출되는 OnCameraUpdated() 함수에서 사용하는 데이터이다.
	LPVOID m_pCameraUpdatedContext;

	////플레이어에 현재 설정된 카메라이다.
	//CCamera *m_pCamera;

public:
	D3DXVECTOR3 GetPosition() { return(m_d3dxvPosition); }
	D3DXVECTOR3 GetLookVector() { return(m_d3dxvLook); }
	D3DXVECTOR3 GetUpVector() { return(m_d3dxvUp); }
	D3DXVECTOR3 GetRightVector() { return(m_d3dxvRight); }

	void SetFriction(float fFriction) { m_fFriction = fFriction; }
	void SetGravity(const D3DXVECTOR3& d3dxvGravity) { m_d3dxvGravity = d3dxvGravity; }
	void SetMaxVelocityXZ(float fMaxVelocity) { m_fMaxVelocityXZ = fMaxVelocity; }
	void SetMaxVelocityY(float fMaxVelocity) { m_fMaxVelocityY = fMaxVelocity; }
	void SetVelocity(const D3DXVECTOR3& d3dxvVelocity) { m_d3dxvVelocity = d3dxvVelocity; }

	

	const D3DXVECTOR3& GetVelocity() const { return(m_d3dxvVelocity); }
	float GetYaw() const { return(m_fYaw); }
	float GetPitch() const { return(m_fPitch); }
	float GetRoll() const { return(m_fRoll); }





	//카메라의 위치가 바뀔 때마다 호출되는 함수와 그 함수에서 사용하는 정보를 설정하는 함수이다.
	virtual void OnCameraUpdated(float fTimeElapsed);
	void SetCameraUpdatedContext(LPVOID pContext) { m_pCameraUpdatedContext = pContext; }

	//카메라를 변경할 때 호출되는 함수이다.
	CCamera *OnChangeCamera(ID3D11Device *pd3dDevice, DWORD nNewCameraMode, DWORD nCurrentCameraMode);

	virtual void ChangeCamera(ID3D11Device *pd3dDevice, DWORD nNewCameraMode, float fTimeElapsed);
	//플레이어의 위치와 회전축으로부터 월드 변환 행렬을 생성하는 함수이다.
	virtual void OnPrepareRender();
	//플레이어의 카메라가 3인칭 카메라일 때 플레이어 메쉬를 렌더링한다.
	virtual void Render(ID3D11DeviceContext *pd3dDeviceContext, CCamera *pCamera);

	virtual  void Animate(float fTimeElapsed);

	virtual void CheckMove(float fTime)
	{
		m_d3dxmtxWorld._43 += fTime;
	}
protected:
	int m_nDirectionState;
	D3DXVECTOR3 m_d3dxvDirection;
	D3DXVECTOR3 m_d3dxvPreDir;
	float CalculateRotation(D3DXVECTOR3 d3dxvInputDir);
};


class CTerrainPlayer : public CPlayer
{
public:
	CTerrainPlayer(ID3D11Device *pd3dDevice, int nMeshes = 1);
	virtual ~CTerrainPlayer(){}

	virtual void ChangeCamera(ID3D11Device *pd3dDevice, DWORD nNewCameraMode, float fTimeElapsed);
	virtual void OnPlayerUpdated(float fTimeElapsed);
	virtual void OnCameraUpdated(float fTimeElapsed);

	virtual  void Animate(float fTimeElapsed);

	virtual void CheckMove(float fTime)
	{
		m_d3dxvPosition.z += fTime;
	}

};
