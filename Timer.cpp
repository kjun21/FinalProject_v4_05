//-----------------------------------------------------------------------------
// File: CGameTimer.cpp
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "Timer.h"
using namespace std;
CGameTimer::CGameTimer()
{
	//고성능 타이머가 있으면
	if (QueryPerformanceFrequency((LARGE_INTEGER *)&m_PerformanceFrequency)) 
    { 
		m_bHardwareHasPerformanceCounter = TRUE; // PerformanceCounter가 있다.
		QueryPerformanceCounter((LARGE_INTEGER *)&m_nLastTime); 
		m_fTimeScale = 1.0f / m_PerformanceFrequency;
	} 
    else 
    { 
		m_bHardwareHasPerformanceCounter = FALSE;
		m_nLastTime	= ::timeGetTime(); 
		m_fTimeScale = 0.001f;	//시간 단위 0.001초
    }

    m_nSampleCount = 0;
	m_nCurrentFrameRate = 0;
	m_FramePerSecond = 0;
	m_fFPSTimeElapsed = 0.0f;
}

CGameTimer::~CGameTimer()
{
}

void CGameTimer::Tick(float fLockFPS)
{
    float fTimeElapsed; 

	//성능 카운터와 성능 주파수를 사용하여 현재 시간을 갱신한다.
	if (m_bHardwareHasPerformanceCounter) 
    {
		QueryPerformanceCounter((LARGE_INTEGER *)&m_nCurrentTime); //현재 시간
	} 
    else 
    {
		m_nCurrentTime = ::timeGetTime();
	} 

	
	fTimeElapsed = (m_nCurrentTime - m_nLastTime) * m_fTimeScale; //프레임 타임
	//cout << "현재 시각 : " <<1/ fTimeElapsed << endl;
    if (fLockFPS > 0.0f)
    {
		//이 함수의 파라메터(fLockFPS)가 0보다 크면 이 시간만큼 호출한 함수를 기다리게 한다.
        while (fTimeElapsed < (1.0f / fLockFPS))
        {
	        if (m_bHardwareHasPerformanceCounter) 
            {
		        QueryPerformanceCounter((LARGE_INTEGER *)&m_nCurrentTime);
	        } 
            else 
            {
				m_nCurrentTime = ::timeGetTime();
			
	        } 
			//마지막으로 이 함수를 호출한 이후 경과한 시간을 계산한다.
	        fTimeElapsed = (m_nCurrentTime - m_nLastTime) * m_fTimeScale;
        }
    } 
	//현재 시간을 m_nLastTime에 저장한다.
	m_nLastTime = m_nCurrentTime;
	//Sleep(2000);
	/* 마지막 프레임 처리 시간과 현재 프레임 처리 시간의 차이가 
	1초보다 작으면 현재 프레임 처리 시간을 m_fFrameTime[0]에 저장한다. */
    if (fabsf(fTimeElapsed - m_fTimeElapsed) < 1.0f)
    {
		//cout << "됨" << endl;
        // Wrap FIFO frame time buffer.
        memmove(&m_fFrameTime[1], m_fFrameTime, (MAX_SAMPLE_COUNT - 1) * sizeof(float));
		
		m_fFrameTime[0] = fTimeElapsed;
        if (m_nSampleCount < MAX_SAMPLE_COUNT)
			m_nSampleCount++;
		
    }

	//초당 프레임 수를 1 증가시키고 현재 프레임 처리 시간을 누적하여 저장한다.
	m_FramePerSecond++;
	//cout << "초당 프레임 수"<<m_FramePerSecond << endl;

	m_fFPSTimeElapsed += fTimeElapsed;
	//cout << "프레임 레이트 계산 소요 시간" << m_fFPSTimeElapsed << endl;
	if (m_fFPSTimeElapsed > 1.0f) //왜 1로 했을까
    { 
		m_nCurrentFrameRate	= m_FramePerSecond;
		//cout << "최종 FPS :"<<m_nCurrentFrameRate << endl;
		m_FramePerSecond = 0;
		m_fFPSTimeElapsed = 0.0f;
	} 

    //누적된 프레임 처리 시간의 평균을 구하여 프레임 처리 시간을 구한다.
    m_fTimeElapsed = 0.0f;
    for (ULONG i = 0; i < m_nSampleCount; i++)
		m_fTimeElapsed += m_fFrameTime[i];
    if (m_nSampleCount > 0) 
		m_fTimeElapsed /= m_nSampleCount;

	/*cout << "fps" << m_nCurrentFrameRate << endl;
	cout << "elapsed" << 1/m_fTimeElapsed << endl;*/
}

unsigned long CGameTimer::GetFrameRate(LPTSTR lpszString, int nCharacters) const
{
	//현재 프레임 레이트를 문자열로 변환하여 lpszString 버퍼에 쓰고 “ FPS”와 결합한다.
    if (lpszString)
    {
        _itow_s(m_nCurrentFrameRate, lpszString, nCharacters, 10);
        wcscat_s(lpszString, nCharacters, _T(" FPS)"));
    } 

		//cout << "프레임 : " << m_nCurrentFrameRate << endl;
		return(m_nCurrentFrameRate);
}

float CGameTimer::GetTimeElapsed() const
{
    return(m_fTimeElapsed);
}
